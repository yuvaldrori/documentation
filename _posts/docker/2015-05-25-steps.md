---
title: Steps Configuration
layout: page
weight: 55
tags:
  - docker
  - jet
  - configuration
  - steps
categories:
  - docker
---

* include a table of contents
{:toc}

Steps are used for the `jet steps` command, which defines your continuous integration and delivery steps. By default, steps are expected to be in one of these 4 files:

* `jet-steps.yml`
* `jet-steps.json`
* `codeship-steps.yml`
* `codeship-steps.json`

_Jet_ will look for a steps file in this order. If you are running _Jet_ locally, you can override the filename with the `--steps-path` flag. Both YAML and JSON formats are accepted.

Steps are specified in a list, such as:

```yml
- name: foo_step
  tag: master
  service: app
  command: echo foo
- name: bar_step
  service: app
  command: echo bar
```

Steps are executed in the order they are specified. All steps share two directives:

* `name` specifies the name of the step, outputted in the logs. This must be unique for all steps. **This field is optional** and will be auto-generated if not specified.
* `tag` this says to only execute this step for the given "tag". Within Codeship this will be the branch or tag name. You can specify this locally via the `--tag` flag. This field is optional.

There are two main kinds of steps, group steps and run steps.

## Group Steps

There are three types of group steps:

* `parallel` run the sub-steps in parallel. Feel free to specify this recursively as much as you want, _Jet_ will just max out the number of available processors. If any sub-step fails, the parallel step fails as well.
* `serial` run the sub-steps serially. This is useful for grouping within parallel steps.

Group steps share the following four directives:

* `type` the step type, either `parallel` or `serial`.
* `steps` a list of sub-steps.
* `service` or `services` which specify a service or list of services for your steps to run on.

`service` is a single string, `services` is a list of strings. At most one of these can be specified. If you specify a service at the group level you cannot specify a service for an individual run step. If you specify a list of services, all sub-steps will be run in one of two ways.

* For parallel steps, the sub-steps will be run as if you specified a serial step containing the sub-steps for each service.
* For serial steps, the services will be run in parallel.

Since that's confusing, here's a logically equivalent example:

```yaml
# Example 1
- type parallel
  steps:
  - type: serial
    steps:
      - service: foo
        command: echo one
      - service: foo
        command: echo two
  - type: serial
    steps:
      - service: bar
        command: echo one
      - service: bar
        command: echo two

# the same as the above
- type parallel
  services:
  - foo
  - bar
  steps:
  - command: echo one
  - command: echo two

# Example 2
- service: foo
  command: echo one
- service: foo
  command: echo two
- service: bar
  command: echo one
- service: bar
  command: echo two

# the same as the above
- type serial
  services:
  - foo
  - bar
  steps:
  - command: echo one
  - command: echo two
```

## Run steps

Run steps specify a command to run on a service. You must specify one or two directives:

* `command` the command to run. This is always required, and identifies a step as a run step. Note that quotes are respected to split up arguments, but special characters such as `&&`, `|` or `>` are not.
* `service` the service to run the command on. If you already specified a service at the group level you can not specify a service again, otherwise this directive is required.

## Push steps

<br />
<div class="info-block">
We currently tag images with `latest`. Going forward we'd like to work with you to better support the way you use tags with Docker. What's your tagging strategy at the moment? Let us know at [support@codeship.com](mailto:support@codeship.com).
</div>

Push steps allow a generated container to be pushed to a remote docker registry. When running after a build, this allows a deployment based upon the successful build to occur. You must specify a number of directives:

*  `type` this must be set to push.
*  `service` the service to run the command on. If the run step is a sub-step of a parallel step, `service` cannot be specified, otherwise it is required.
*  `name` the name of this push step.
*  `image_name` the name of the generated image as it exists in your service.yml/json file, in the format `[registry/][owner/]name[:tag]`.
*  `registry` the url of the registry being pushed to. For Dockerhub, use `https://index.docker.io/v1/`.
*  `encrypted_dockercfg_path` the path to your relevant dockercfg file, encrypted using `jet encrypt`.
*  `tag` a group tag associated with this build step (optional).

When using a private repository, or a non-standard tag, keep in mind your step directives _MUST_ match your service descriptions. In order to use a private registry, the `image_name` directive in your steps file needs to match the `image_name` from `codeship_services.yml`, and should look something like `myregistry.mydomain.com:5002/myuser/myrepo`.

Before an image can be pushed, it must be built, so ensure your relevant image is represented in a previous step in your build pipeline, even if it is just a simple command being run inside the container. This will ensure the image is available to be pushed.

As for the `encrypted_dockercfg_path` directive, we support both, the older `.dockercfg` as well as the newer `${HOME}/.docker/config.json` format. You can simply encrypt either of those files via `jet encrypt` and commit the encrypted files to the repository and the configuration will be picked up.

Please see our [Docker Push Tutorial]({{ site.baseurl }}{% post_url docker/tutorials/2015-07-03-docker-push %}) for an example on how to push to [Quay.io](https://quay.io) or the Docker Hub.
